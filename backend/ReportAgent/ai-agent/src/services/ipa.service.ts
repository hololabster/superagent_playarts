import {
  aeneidRoyaltyPolicy,
  defaultLicenseTermData,
} from "@/constants/storyIpaConfig";
import { createMetadataHash, uploadJSONToIPFS } from "@/utils/ipfs";
import { StoryClient, WIP_TOKEN_ADDRESS } from "@story-protocol/core-sdk";
import { createHash } from "crypto";
import { zeroAddress, zeroHash, parseEther } from "viem";
import { mintNFTOnChain } from "./onChain.service";
import { CONTRACT_ADDRESSES } from "@/constants/chains";
import { COMMERCIAL_REV_SHARE } from "@/constants/price";

const licensingConfig = {
  isSet: false,
  mintingFee: BigInt(0),
  licensingHook: zeroAddress,
  hookData: zeroHash,
  commercialRevShare: 10,
  disabled: false,
  expectMinimumGroupRewardShare: 0,
  expectGroupRewardPool: zeroAddress,
};

export const mintAndRegisterIpa = async (
  client: StoryClient,
  imageUrl: string,
  agent: boolean = false,
  agentUrl?: string,
  agentName?: string
) => {
  if (!client) return;

  const ipMetadata = {
    title: agent ? agentName : "Playarts AI image NFT",
    description: agent
      ? "AI Agent generated by playarts"
      : "AI Image generated by playarts",
    image: imageUrl,
    imageHash: createHash("sha256").update(imageUrl).digest("hex"),
    mediaUrl: imageUrl,
    mediaHash: createHash("sha256").update(imageUrl).digest("hex"),
    mediaType: "image/jpeg",
    creators: [
      {
        name: "Playarts",
        address: "0x859e651Ca5c8055CdC504517941EBdCDf74dD2e2",
        description: "Playarts is cool",
        contributionPercent: 100,
        socialMedia: [
          {
            platform: "Twitter",
            url: "https://x.com/playartsdotai",
          },
        ],
      },
    ],
  };
  if (agent) {
    ipMetadata.aiMetadata = {
      characterFileUrl: agentUrl, // 에이전트의 설정 파일 또는 프롬프트 정의
      characterFileHash: createHash("sha256").update(agentUrl).digest("hex"),
    };
    ipMetadata.ipType = "AI Agent"; // experimental field
    ipMetadata.tags = [
      "AI Agent",
      "Twitter bot",
      "Smart Agent",
      "Playarts",
      "PlayartsDotAi",
    ]; // experimental field
  }

  const nftMetadata = {
    name: agent ? agentName : "Playarts AI image NFT",
    description: agent
      ? "AI Agent generated by playarts"
      : "AI Image generated by playarts",
    image: imageUrl,
  };
  if (agent) {
    nftMetadata.external_url = agentUrl;
  }
  // Upload metadata to IPFS
  const ipIpfsHash = await uploadJSONToIPFS(ipMetadata);
  const ipHash = createMetadataHash(ipMetadata);
  const nftIpfsHash = await uploadJSONToIPFS(nftMetadata);
  const nftHash = createMetadataHash(nftMetadata);

  // Mint
  const { txHash, receipt, tokenId } = await mintNFTOnChain(
    `https://ipfs.io/ipfs/${nftIpfsHash}`
  );

  console.log(txHash, receipt, tokenId);

  // Register IP
  const response = await client.ipAsset.registerIpAndAttachPilTerms({
    nftContract: CONTRACT_ADDRESSES[1315],
    tokenId,
    licenseTermsData: [{ terms: defaultLicenseTermData, licensingConfig }], // 라이선스 정책
    ipMetadata: {
      ipMetadataURI: `https://ipfs.io/ipfs/${ipIpfsHash}`,
      ipMetadataHash: `0x${ipHash}`,
      nftMetadataURI: `https://ipfs.io/ipfs/${nftIpfsHash}`,
      nftMetadataHash: `0x${nftHash}`,
    },
    txOptions: {
      waitForTransaction: true,
    },
  });

  const result = {
    txHash: response.txHash,
    ipId: response.ipId,
    licenseTermsIds: response.licenseTermsIds,
  };
  console.log(result);

  return result;
};

export interface MintLicenseResponse {
  txHash: string;
  licenseTokenIds: string[];
}
export async function mintLicenseToken(
  client: StoryClient,
  params: {
    licenseTermsId: string;
    licensorIpId: string;
    receiver?: string; // 선택사항, 없으면 트랜잭션 보낸 사람에게 발행
    amount: number;
    maxMintingFee?: bigint; // 선택사항, 발행 수수료 제한
    maxRevenueShare?: number; // 선택사항, 기본값 100
    parentIpId?: string; // 선택사항, 있을 경우 Root 소유자에게 수익 분배
  }
): Promise<MintLicenseResponse> {
  try {
    const response = await client.license.mintLicenseTokens({
      licenseTermsId: params.licenseTermsId,
      licensorIpId: params.licensorIpId,
      receiver: params.receiver,
      amount: params.amount.toString(),
      maxMintingFee: params.maxMintingFee || BigInt(0),
      maxRevenueShare: params.maxRevenueShare || 100,
      txOptions: {
        waitForTransaction: true,
      },
    });

    if (params.parentIpId) {
      const payRoyalty = await client.royalty.payRoyaltyOnBehalf({
        receiverIpId: params.parentIpId, // parentIpId
        payerIpId: params.licensorIpId, // childIpId
        token: WIP_TOKEN_ADDRESS,
        amount: parseEther(
          (params.amount * (COMMERCIAL_REV_SHARE / 100)).toString()
        ),
        txOptions: { waitForTransaction: true },
      });

      console.log(`Paid royalty at transaction hash ${payRoyalty.txHash}`);
    }

    return {
      txHash: response.txHash,
      licenseTokenIds: response.licenseTokenIds,
    };
  } catch (error) {
    console.error("Failed to mint license token:", error);
    throw error;
  }
}

/**
 * 모든 가능한 수익을 한 번에 청구하는 함수
 * @param ipId 수익을 청구하려는 IP 자산의 ID
 * @param childIpIds 파생 IP 자산의 ID 배열
 * @param royaltyPolicyAddresses 로열티 정책 주소 배열
 * @param claimerAddress 로열티 토큰을 소유한 주소 (대개 ipId와 동일)
 * @returns 청구된 토큰 정보
 */
export async function claimAllPossibleRevenue(
  client: StoryClient,
  ipId: string,
  childIpIds?: string[],
  royaltyPolicyAddresses?: string[],
  claimerAddress?: string
) {
  try {
    // 클레이머가 지정되지 않은 경우 IP ID를 사용
    const claimer = claimerAddress || ipId;

    const claimRevenue = await client.royalty.claimAllRevenue({
      ancestorIpId: ipId,
      claimer: claimer,
      currencyTokens: [WIP_TOKEN_ADDRESS],
      childIpIds: childIpIds,
      royaltyPolicies: royaltyPolicyAddresses || [aeneidRoyaltyPolicy],
      claimOptions: {
        autoTransferAllClaimedTokensFromIp: true,
        autoUnwrapIpTokens: true,
      },
    });

    return claimRevenue;
  } catch (error) {
    throw error;
  }
}
